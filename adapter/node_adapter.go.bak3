// (c) 2019-2020, Lux Industries, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package adapter

import (
	"context"
	"time"

	"github.com/luxfi/evm/interfaces"
	
	// We'll still need to import from node for the actual implementations
	// but now the EVM code will use interfaces instead of direct imports
	nodeids "github.com/luxfi/evm/interfaces"
	nodedb "github.com/luxfi/evm/interfaces"
	nodeconsensus "github.com/luxfi/evm/interfaces"
	nodevalidators "github.com/luxfi/node/consensus/validators"
	nodeblock "github.com/luxfi/node/consensus/engine/linear/block"
	nodelinear "github.com/luxfi/node/consensus/linear"
	nodechoices "github.com/luxfi/node/consensus/choices"
	nodechain "github.com/luxfi/node/vms/components/chain"
	nodeengine "github.com/luxfi/node/consensus/engine/core"
	nodewarp "github.com/luxfi/node/vms/platformvm/warp"
)

// IDAdapter converts between node IDs and interface IDs
type IDAdapter struct {
	id nodeinterfaces.ID
}

func NewIDAdapter(id nodeinterfaces.ID) interfaces.BlockID {
	var blockID interfaces.BlockID
	copy(blockID[:], id[:])
	return blockID
}

func NodeIDFromInterface(id interfaces.BlockID) nodeinterfaces.ID {
	var nodeID nodeinterfaces.ID
	copy(nodeID[:], id[:])
	return nodeID
}

// BlockAdapter adapts node blocks to interface blocks
type BlockAdapter struct {
	block nodelinear.Block
}

func NewBlockAdapter(block nodelinear.Block) interfaces.NodeBlock {
	return &BlockAdapter{block: block}
}

func (b *BlockAdapter) ID() interfaces.BlockID {
	return NewIDAdapter(b.block.ID())
}

func (b *BlockAdapter) Parent() interfaces.BlockID {
	return NewIDAdapter(b.block.Parent())
}

func (b *BlockAdapter) Height() uint64 {
	return b.block.Height()
}

func (b *BlockAdapter) Timestamp() uint64 {
	return uint64(b.block.Timestamp().Unix())
}

func (b *BlockAdapter) Bytes() []byte {
	return b.block.Bytes()
}

func (b *BlockAdapter) Verify(ctx context.Context) error {
	return b.block.Verify(ctx)
}

func (b *BlockAdapter) Accept(ctx context.Context) error {
	return b.block.Accept(ctx)
}

func (b *BlockAdapter) Reject(ctx context.Context) error {
	return b.block.Reject(ctx)
}

// DatabaseAdapter adapts node database to interface database
type DatabaseAdapter struct {
	db nodedb.Database
}

func NewDatabaseAdapter(db nodedb.Database) interfaces.Database {
	return &DatabaseAdapter{db: db}
}

func (d *DatabaseAdapter) Has(key []byte) (bool, error) {
	return d.db.Has(key)
}

func (d *DatabaseAdapter) Get(key []byte) ([]byte, error) {
	return d.db.Get(key)
}

func (d *DatabaseAdapter) Put(key []byte, value []byte) error {
	return d.db.Put(key, value)
}

func (d *DatabaseAdapter) Delete(key []byte) error {
	return d.db.Delete(key)
}

func (d *DatabaseAdapter) NewBatch() interfaces.Batch {
	return d.db.NewBatch()
}

func (d *DatabaseAdapter) NewIterator(prefix []byte, start []byte) interfaces.Iterator {
	return d.db.NewIterator(prefix, start)
}

func (d *DatabaseAdapter) Close() error {
	return d.db.Close()
}

func (d *DatabaseAdapter) HealthCheck() (interface{}, error) {
	return d.db.HealthCheck(context.Background())
}

func (d *DatabaseAdapter) Compact(start []byte, limit []byte) error {
	return d.db.Compact(start, limit)
}

// ConsensusAdapter adapts node consensus to interface consensus
type ConsensusAdapter struct {
	consensus nodeinterfaces.ChainContext
}

func NewConsensusAdapter(consensus *nodeinterfaces.ChainContext) interfaces.NodeConsensus {
	return &ConsensusAdapter{consensus: *consensus}
}

func (c *ConsensusAdapter) GetConsensusParamsAt(ctx context.Context, blockHeight uint64) (*interfaces.NodeConsensusParams, error) {
	// Map node consensus params to interface params
	return &interfaces.NodeConsensusParams{
		BlockGasCost:             0, // Set appropriate values
		BlockGasLimit:            8000000,
		MinBaseFee:               25000000000,
		TargetBlockRate:          2,
		BaseFeeChangeDenominator: 36,
		MinBlockGasCost:          0,
		MaxBlockGasCost:          10000000,
		BlockGasCostStep:         200000,
	}, nil
}

func (c *ConsensusAdapter) IsUpgradeActive(upgradeID string, timestamp uint64) bool {
	// Check if upgrade is active based on timestamp
	return false // Implement based on actual upgrade schedule
}

// ValidatorStateAdapter adapts node validator state to interface
type ValidatorStateAdapter struct {
	state nodevalidators.State
}

func NewValidatorStateAdapter(state nodevalidators.State) interfaces.ValidatorState {
	return &ValidatorStateAdapter{state: state}
}

func (v *ValidatorStateAdapter) GetCurrentHeight(ctx context.Context) (uint64, error) {
	return v.state.GetCurrentHeight(ctx)
}

func (v *ValidatorStateAdapter) GetValidatorSet(ctx context.Context, height uint64, subnetID interfaces.SubnetID) (map[interfaces.NodeID]*interfaces.ValidatorData, error) {
	// Convert interface SubnetID to node SubnetID
	var nodeSubnetID nodeinterfaces.ID
	copy(nodeSubnetID[:], subnetID[:])
	
	nodeValidators, err := v.state.GetValidatorSet(ctx, height, nodeSubnetID)
	if err != nil {
		return nil, err
	}
	
	// Convert node validators to interface validators
	validators := make(map[interfaces.NodeID]*interfaces.ValidatorData)
	for nodeID, validator := range nodeValidators {
		var interfaceNodeID interfaces.NodeID
		copy(interfaceNodeID[:], nodeID[:])
		
		validators[interfaceNodeID] = &interfaces.ValidatorData{
			NodeID:    interfaceNodeID,
			PublicKey: validator.PublicKey,
			Weight:    validator.Weight,
		}
	}
	
	return validators, nil
}

func (v *ValidatorStateAdapter) GetMinimumHeight(ctx context.Context) (uint64, error) {
	return v.state.GetMinimumHeight(ctx)
}

// ChoiceAdapter converts between node choices and interface choices
func ChoiceAdapter(choice nodechoices.Status) interfaces.Choice {
	switch choice {
	case nodechoices.Unknown:
		return interfaces.Undecided
	case nodechoices.Processing:
		return interfaces.Processing
	case nodechoices.Accepted:
		return interfaces.Accepted
	case nodechoices.Rejected:
		return interfaces.Rejected
	default:
		return interfaces.Undecided
	}
}

// WarpBackendAdapter adapts node warp backend to interface
type WarpBackendAdapter struct {
	backend nodewarp.Backend
}

func NewWarpBackendAdapter(backend nodewarp.Backend) interfaces.WarpBackend {
	return &WarpBackendAdapter{backend: backend}
}

func (w *WarpBackendAdapter) GetBlockSignature(ctx context.Context, blockID interfaces.BlockID) (*interfaces.WarpSignature, error) {
	nodeBlockID := NodeIDFromInterface(blockID)
	sig, err := w.backend.GetBlockSignature(ctx, nodeBlockID)
	if err != nil {
		return nil, err
	}
	
	return &interfaces.WarpSignature{
		Signers:   sig.Signers,
		Signature: sig.Signature,
	}, nil
}

func (w *WarpBackendAdapter) GetMessageSignature(ctx context.Context, msg *interfaces.WarpUnsignedMessage) (*interfaces.WarpSignature, error) {
	// Convert interface message to node message
	nodeMsg := &nodewarp.UnsignedMessage{
		NetworkID:     msg.NetworkID,
		SourceChainID: nodeinterfaces.ID(msg.SourceChainID),
		Payload:       msg.Payload,
	}
	
	sig, err := w.backend.GetMessageSignature(ctx, nodeMsg)
	if err != nil {
		return nil, err
	}
	
	return &interfaces.WarpSignature{
		Signers:   sig.Signers,
		Signature: sig.Signature,
	}, nil
}

func (w *WarpBackendAdapter) AddMessage(ctx context.Context, msg *interfaces.WarpUnsignedMessage) error {
	// Convert interface message to node message
	nodeMsg := &nodewarp.UnsignedMessage{
		NetworkID:     msg.NetworkID,
		SourceChainID: nodeinterfaces.ID(msg.SourceChainID),
		Payload:       msg.Payload,
	}
	
	return w.backend.AddMessage(ctx, nodeMsg)
}