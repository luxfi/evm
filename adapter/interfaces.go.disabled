// Copyright (C) 2019-2024, Lux Industries Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package adapter

import (
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	
	evmcore "github.com/luxfi/evm/core"
	evmstate "github.com/ethereum/go-ethereum/core/state"
	evmparams "github.com/luxfi/evm/params"
	evmconsensus "github.com/luxfi/evm/consensus"
	
	gethcore "github.com/luxfi/evm/core"
	gethstate "github.com/ethereum/go-ethereum/core/state"
	gethparams "github.com/luxfi/evm/params"
	gethconsensus "github.com/luxfi/evm/consensus"
	gethvm "github.com/ethereum/go-ethereum/core/vm"
)

// ChainContextAdapter adapts EVM ChainContext to geth ChainContext
type ChainContextAdapter struct {
	ctx *evmcore.ChainContext
	engine gethconsensus.Engine
}

func NewChainContextAdapter(ctx *evmcore.ChainContext, engine gethconsensus.Engine) gethcore.ChainContext {
	return &ChainContextAdapter{
		ctx: ctx,
		engine: engine,
	}
}

func (c *ChainContextAdapter) Engine() gethconsensus.Engine {
	return c.engine
}

func (c *ChainContextAdapter) GetHeader(hash common.Hash, number uint64) *types.Header {
	// Delegate to the EVM implementation
	return c.ctx.GetHeader(hash, number)
}

// StateDBAdapter wraps EVM StateDB to implement geth StateDB interface
type StateDBAdapter struct {
	*evmstate.StateDB
}

func NewStateDBAdapter(stateDB *evmstate.StateDB) gethvm.StateDB {
	return &StateDBAdapter{StateDB: stateDB}
}

// Implement any missing methods that geth expects but EVM doesn't have
func (s *StateDBAdapter) Prepare(rules gethparams.Rules, sender, coinbase common.Address, dest *common.Address, precompiles []common.Address, txAccesses types.AccessList) {
	// Convert geth rules to EVM rules if needed
	evmRules := evmparams.Rules{
		ChainID:                     rules.ChainID,
		IsHomestead:                 rules.IsHomestead,
		IsEIP150:                    rules.IsEIP150,
		IsEIP155:                    rules.IsEIP155,
		IsEIP158:                    rules.IsEIP158,
		IsByzantium:                 rules.IsByzantium,
		IsConstantinople:            rules.IsConstantinople,
		IsPetersburg:                rules.IsPetersburg,
		IsIstanbul:                  rules.IsIstanbul,
		IsBerlin:                    rules.IsBerlin,
		IsLondon:                    rules.IsLondon,
		IsMerge:                     rules.IsMerge,
		IsShanghai:                  rules.IsShanghai,
		IsCancun:                    rules.IsCancun,
		IsPrague:                    rules.IsPrague,
	}
	s.StateDB.Prepare(evmRules, sender, coinbase, dest, precompiles, txAccesses)
}

// ChainConfigAdapter converts between EVM and geth ChainConfig
func ChainConfigAdapter(evmConfig *evmparams.ChainConfig) *gethparams.ChainConfig {
	return &gethparams.ChainConfig{
		ChainID:                 evmConfig.ChainID,
		HomesteadBlock:          evmConfig.HomesteadBlock,
		DAOForkBlock:            evmConfig.DAOForkBlock,
		DAOForkSupport:          evmConfig.DAOForkSupport,
		EIP150Block:             evmConfig.EIP150Block,
		EIP155Block:             evmConfig.EIP155Block,
		EIP158Block:             evmConfig.EIP158Block,
		ByzantiumBlock:          evmConfig.ByzantiumBlock,
		ConstantinopleBlock:     evmConfig.ConstantinopleBlock,
		PetersburgBlock:         evmConfig.PetersburgBlock,
		IstanbulBlock:           evmConfig.IstanbulBlock,
		MuirGlacierBlock:        evmConfig.MuirGlacierBlock,
		BerlinBlock:             evmConfig.BerlinBlock,
		LondonBlock:             evmConfig.LondonBlock,
		TerminalTotalDifficulty: evmConfig.TerminalTotalDifficulty,
		MergeNetsplitBlock:      evmConfig.MergeNetsplitBlock,
		ShanghaiTime:            evmConfig.ShanghaiTime,
		CancunTime:              evmConfig.CancunTime,
		PragueTime:              evmConfig.PragueTime,
	}
}

// EngineAdapter wraps EVM consensus engine to implement geth consensus.Engine
type EngineAdapter struct {
	engine evmconsensus.Engine
}

func NewEngineAdapter(engine evmconsensus.Engine) gethconsensus.Engine {
	return &EngineAdapter{engine: engine}
}

func (e *EngineAdapter) Author(header *types.Header) (common.Address, error) {
	return e.engine.Author(header)
}

func (e *EngineAdapter) VerifyHeader(chain gethconsensus.ChainHeaderReader, header *types.Header) error {
	// Create an adapter if needed
	return e.engine.VerifyHeader(chain, header)
}

func (e *EngineAdapter) VerifyHeaders(chain gethconsensus.ChainHeaderReader, headers []*types.Header) (chan<- struct{}, <-chan error) {
	return e.engine.VerifyHeaders(chain, headers)
}

func (e *EngineAdapter) VerifyUncles(chain gethconsensus.ChainReader, block *types.Block) error {
	return e.engine.VerifyUncles(chain, block)
}

func (e *EngineAdapter) Prepare(chain gethconsensus.ChainHeaderReader, header *types.Header) error {
	return e.engine.Prepare(chain, header)
}

func (e *EngineAdapter) Finalize(chain gethconsensus.ChainHeaderReader, header *types.Header, state gethvm.StateDB, body *types.Body) {
	// Convert geth StateDB to EVM StateDB if needed
	if stateAdapter, ok := state.(*StateDBAdapter); ok {
		e.engine.Finalize(chain, header, stateAdapter.StateDB, body)
	}
}

func (e *EngineAdapter) FinalizeAndAssemble(chain gethconsensus.ChainHeaderReader, header *types.Header, state gethvm.StateDB, body *types.Body, receipts []*types.Receipt) (*types.Block, error) {
	if stateAdapter, ok := state.(*StateDBAdapter); ok {
		return e.engine.FinalizeAndAssemble(chain, header, stateAdapter.StateDB, body, receipts)
	}
	return nil, gethconsensus.ErrUnknownAncestor
}

func (e *EngineAdapter) Seal(chain gethconsensus.ChainHeaderReader, block *types.Block, results chan<- *types.Block, stop <-chan struct{}) error {
	return e.engine.Seal(chain, block, results, stop)
}

func (e *EngineAdapter) SealHash(header *types.Header) common.Hash {
	return e.engine.SealHash(header)
}

func (e *EngineAdapter) CalcDifficulty(chain gethconsensus.ChainHeaderReader, time uint64, parent *types.Header) *big.Int {
	return e.engine.CalcDifficulty(chain, time, parent)
}

func (e *EngineAdapter) APIs(chain gethconsensus.ChainHeaderReader) []gethconsensus.API {
	// Convert EVM APIs to geth APIs
	evmAPIs := e.engine.APIs(chain)
	gethAPIs := make([]gethconsensus.API, len(evmAPIs))
	for i, api := range evmAPIs {
		gethAPIs[i] = gethconsensus.API{
			Namespace: api.Namespace,
			Service:   api.Service,
		}
	}
	return gethAPIs
}

func (e *EngineAdapter) Close() error {
	return e.engine.Close()
}